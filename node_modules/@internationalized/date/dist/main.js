var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));

var _babelRuntimeHelpersClassPrivateFieldLooseKey = $parcel$interopDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// Data from https://github.com/unicode-cldr/cldr-core/blob/master/supplemental/weekData.json
// Locales starting on Sunday have been removed for compression.
const $f9329ef83b780ce5cb2b5b95239f8$export$weekStartData = {
  '001': 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AT: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};

function isSameDay(a, b) {
  b = toCalendar(b, a.calendar);
  return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}

exports.isSameDay = isSameDay;

function isSameMonth(a, b) {
  b = toCalendar(b, a.calendar); // In the Japanese calendar, months can span multiple eras/years, so only compare the first of the month.

  a = startOfMonth(a);
  b = startOfMonth(b);
  return a.era === b.era && a.year === b.year && a.month === b.month;
}

exports.isSameMonth = isSameMonth;

function isSameYear(a, b) {
  b = toCalendar(b, a.calendar);
  a = startOfYear(a);
  b = startOfYear(b);
  return a.era === b.era && a.year === b.year;
}

exports.isSameYear = isSameYear;

function isEqualDay(a, b) {
  return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}

exports.isEqualDay = isEqualDay;

function isEqualMonth(a, b) {
  a = startOfMonth(a);
  b = startOfMonth(b);
  return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month;
}

exports.isEqualMonth = isEqualMonth;

function isEqualYear(a, b) {
  a = startOfYear(a);
  b = startOfYear(b);
  return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year;
}

exports.isEqualYear = isEqualYear;

function isToday(date, timeZone) {
  return isSameDay(date, today(timeZone));
}

exports.isToday = isToday;

function getDayOfWeek(date, locale) {
  let julian = date.calendar.toJulianDay(date); // If julian is negative, then julian % 7 will be negative, so we adjust
  // accordingly.  Julian day 0 is Monday.

  let dayOfWeek = Math.ceil(julian + 1 - $ca0cdda43bc8e7de0f5e86$var$getWeekStart(locale)) % 7;

  if (dayOfWeek < 0) {
    dayOfWeek += 7;
  }

  return dayOfWeek;
}

exports.getDayOfWeek = getDayOfWeek;

function now(timeZone) {
  return fromAbsolute(Date.now(), timeZone);
}

exports.now = now;

function today(timeZone) {
  return toCalendarDate(now(timeZone));
}

exports.today = today;

function compareDate(a, b) {
  return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}

exports.compareDate = compareDate;

function compareTime(a, b) {
  return $ca0cdda43bc8e7de0f5e86$var$timeToMs(a) - $ca0cdda43bc8e7de0f5e86$var$timeToMs(b);
}

exports.compareTime = compareTime;

function $ca0cdda43bc8e7de0f5e86$var$timeToMs(a) {
  return a.hour * 60 * 60 * 1000 + a.minute * 60 * 1000 + a.second * 1000 + a.millisecond;
}

function getHoursInDay(a, timeZone) {
  let ms = toAbsolute(a, timeZone);
  let tomorrow = a.add({
    days: 1
  });
  let tomorrowMs = toAbsolute(tomorrow, timeZone);
  return (tomorrowMs - ms) / 3600000;
}

exports.getHoursInDay = getHoursInDay;
let $ca0cdda43bc8e7de0f5e86$var$localTimeZone = null;

function getLocalTimeZone() {
  // TODO: invalidate this somehow?
  if ($ca0cdda43bc8e7de0f5e86$var$localTimeZone == null) {
    $ca0cdda43bc8e7de0f5e86$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }

  return $ca0cdda43bc8e7de0f5e86$var$localTimeZone;
}

exports.getLocalTimeZone = getLocalTimeZone;

function startOfMonth(date) {
  // Use `subtract` instead of `set` so we don't get constrained in an era.
  return date.subtract({
    days: date.day - 1
  });
}

exports.startOfMonth = startOfMonth;

function endOfMonth(date) {
  return date.add({
    days: date.calendar.getDaysInMonth(date) - date.day
  });
}

exports.endOfMonth = endOfMonth;

function startOfYear(date) {
  return startOfMonth(date.subtract({
    months: date.month - 1
  }));
}

exports.startOfYear = startOfYear;

function endOfYear(date) {
  return endOfMonth(date.add({
    months: date.calendar.getMonthsInYear(date) - date.month
  }));
}

exports.endOfYear = endOfYear;

function getMinimumMonthInYear(date) {
  if (date.calendar.getMinimumMonthInYear) {
    return date.calendar.getMinimumMonthInYear(date);
  }

  return 1;
}

exports.getMinimumMonthInYear = getMinimumMonthInYear;

function getMinimumDayInMonth(date) {
  if (date.calendar.getMinimumDayInMonth) {
    return date.calendar.getMinimumDayInMonth(date);
  }

  return 1;
}

exports.getMinimumDayInMonth = getMinimumDayInMonth;

function startOfWeek(date, locale) {
  let dayOfWeek = getDayOfWeek(date, locale);
  return date.subtract({
    days: dayOfWeek
  });
}

exports.startOfWeek = startOfWeek;

function endOfWeek(date, locale) {
  return startOfWeek(date, locale).add({
    days: 6
  });
}

exports.endOfWeek = endOfWeek;
const $ca0cdda43bc8e7de0f5e86$var$cachedRegions = new Map();

function $ca0cdda43bc8e7de0f5e86$var$getRegion(locale) {
  // If the Intl.Locale API is available, use it to get the region for the locale.
  // @ts-ignore
  if (Intl.Locale) {
    // Constructing an Intl.Locale is expensive, so cache the result.
    let region = $ca0cdda43bc8e7de0f5e86$var$cachedRegions.get(locale);

    if (!region) {
      // @ts-ignore
      region = new Intl.Locale(locale).maximize().region;
      $ca0cdda43bc8e7de0f5e86$var$cachedRegions.set(locale, region);
    }

    return region;
  } // If not, just try splitting the string.
  // If the second part of the locale string is 'u',
  // then this is a unicode extension, so ignore it.
  // Otherwise, it should be the region.


  let part = locale.split('-')[1];
  return part === 'u' ? null : part;
}

function $ca0cdda43bc8e7de0f5e86$var$getWeekStart(locale) {
  // TODO: use Intl.Locale for this once browsers support the weekInfo property
  // https://github.com/tc39/proposal-intl-locale-info
  let region = $ca0cdda43bc8e7de0f5e86$var$getRegion(locale);
  return $f9329ef83b780ce5cb2b5b95239f8$export$weekStartData[region] || 0;
}

function getWeeksInMonth(date, locale) {
  let days = date.calendar.getDaysInMonth(date);
  return Math.ceil((getDayOfWeek(startOfMonth(date), locale) + days) / 7);
}

exports.getWeeksInMonth = getWeeksInMonth;

function minDate(a, b) {
  return a.compare(b) <= 0 ? a : b;
}

exports.minDate = minDate;

function maxDate(a, b) {
  return a.compare(b) >= 0 ? a : b;
}

exports.maxDate = maxDate;

function $f839ba72fcd1ea0f3280c95c38c6e83$export$mod(amount, numerator) {
  return amount - numerator * Math.floor(amount / numerator);
}

const $fdb27fe8d5b8ff356e836fe61f3645c$var$EPOCH = 1721426; // 001/01/03 Julian C.E.

function $fdb27fe8d5b8ff356e836fe61f3645c$export$gregorianToJulianDay(year, month, day) {
  let y1 = year - 1;
  let monthOffset = -2;

  if (month <= 2) {
    monthOffset = 0;
  } else if ($fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(year)) {
    monthOffset = -1;
  }

  return $fdb27fe8d5b8ff356e836fe61f3645c$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}

function $fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

const $fdb27fe8d5b8ff356e836fe61f3645c$var$daysInMonth = {
  standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
};

class GregorianCalendar {
  constructor() {
    this.identifier = 'gregory';
  }

  fromJulianDay(jd) {
    let jd0 = jd;
    let depoch = jd0 - $fdb27fe8d5b8ff356e836fe61f3645c$var$EPOCH;
    let quadricent = Math.floor(depoch / 146097);
    let dqc = $f839ba72fcd1ea0f3280c95c38c6e83$export$mod(depoch, 146097);
    let cent = Math.floor(dqc / 36524);
    let dcent = $f839ba72fcd1ea0f3280c95c38c6e83$export$mod(dqc, 36524);
    let quad = Math.floor(dcent / 1461);
    let dquad = $f839ba72fcd1ea0f3280c95c38c6e83$export$mod(dcent, 1461);
    let yindex = Math.floor(dquad / 365);
    let year = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
    let yearDay = jd0 - $fdb27fe8d5b8ff356e836fe61f3645c$export$gregorianToJulianDay(year, 1, 1);
    let leapAdj = 2;

    if (jd0 < $fdb27fe8d5b8ff356e836fe61f3645c$export$gregorianToJulianDay(year, 3, 1)) {
      leapAdj = 0;
    } else if ($fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(year)) {
      leapAdj = 1;
    }

    let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
    let day = jd0 - $fdb27fe8d5b8ff356e836fe61f3645c$export$gregorianToJulianDay(year, month, 1) + 1;
    return new CalendarDate(this, year, month, day);
  }

  toJulianDay(date) {
    return $fdb27fe8d5b8ff356e836fe61f3645c$export$gregorianToJulianDay(date.year, date.month, date.day);
  }

  getDaysInMonth(date) {
    return $fdb27fe8d5b8ff356e836fe61f3645c$var$daysInMonth[$fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(date.year) ? 'leapyear' : 'standard'][date.month - 1];
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  getMonthsInYear(date) {
    return 12;
  }

  getDaysInYear(date) {
    return $fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(date.year) ? 366 : 365;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  getYearsInEra(date) {
    return 9999;
  }

  getEras() {
    return ['BC', 'AD'];
  }

  getYearsToAdd(date, years) {
    return date.era === 'BC' ? -years : years;
  }

  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === 'BC' ? 'AD' : 'BC';
      date.year = 1 - date.year;
    }
  }

}

exports.GregorianCalendar = GregorianCalendar;

function epochFromDate(date) {
  date = toCalendar(date, new GregorianCalendar());
  return $a64489f6d663f3427da3eac0e9$var$epochFromParts(date.year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}

exports.epochFromDate = epochFromDate;

function $a64489f6d663f3427da3eac0e9$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
  // Note: Date.UTC() interprets one and two-digit years as being in the
  // 20th century, so don't use it
  let date = new Date();
  date.setUTCHours(hour, minute, second, millisecond);
  date.setUTCFullYear(year, month - 1, day);
  return date.getTime();
}

function getTimeZoneOffset(ms, timeZone) {
  // Fast path: for local timezone, use native Date.
  if (timeZone === getLocalTimeZone()) {
    return new Date(ms).getTimezoneOffset() * -60 * 1000;
  }

  let {
    year,
    month,
    day,
    hour,
    minute,
    second
  } = $a64489f6d663f3427da3eac0e9$var$getTimeZoneParts(ms, timeZone);
  let utc = $a64489f6d663f3427da3eac0e9$var$epochFromParts(year, month, day, hour, minute, second, 0);
  return utc - Math.floor(ms / 1000) * 1000;
}

exports.getTimeZoneOffset = getTimeZoneOffset;
const $a64489f6d663f3427da3eac0e9$var$formattersByTimeZone = new Map();

function $a64489f6d663f3427da3eac0e9$var$getTimeZoneParts(ms, timeZone) {
  let formatter = $a64489f6d663f3427da3eac0e9$var$formattersByTimeZone.get(timeZone);

  if (!formatter) {
    formatter = new Intl.DateTimeFormat('en-US', {
      timeZone,
      hour12: false,
      era: 'short',
      year: 'numeric',
      month: 'numeric',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      second: 'numeric'
    });
    $a64489f6d663f3427da3eac0e9$var$formattersByTimeZone.set(timeZone, formatter);
  }

  let parts = formatter.formatToParts(new Date(ms));
  let namedParts = {};

  for (let part of parts) {
    if (part.type !== 'literal') {
      namedParts[part.type] = part.value;
    }
  }

  return {
    year: namedParts.era === 'BC' ? -namedParts.year + 1 : +namedParts.year,
    month: +namedParts.month,
    day: +namedParts.day,
    hour: namedParts.hour === '24' ? 0 : +namedParts.hour,
    // bugs.chromium.org/p/chromium/issues/detail?id=1045791
    minute: +namedParts.minute,
    second: +namedParts.second
  };
}

const $a64489f6d663f3427da3eac0e9$var$DAYMILLIS = 86400000;

function possibleAbsolutes(date, timeZone) {
  let ms = epochFromDate(date);
  let earlier = ms - getTimeZoneOffset(ms - $a64489f6d663f3427da3eac0e9$var$DAYMILLIS, timeZone);
  let later = ms - getTimeZoneOffset(ms + $a64489f6d663f3427da3eac0e9$var$DAYMILLIS, timeZone);
  return $a64489f6d663f3427da3eac0e9$var$getValidWallTimes(date, timeZone, earlier, later);
}

exports.possibleAbsolutes = possibleAbsolutes;

function $a64489f6d663f3427da3eac0e9$var$getValidWallTimes(date, timeZone, earlier, later) {
  let found = earlier === later ? [earlier] : [earlier, later];
  return found.filter(absolute => $a64489f6d663f3427da3eac0e9$var$isValidWallTime(date, timeZone, absolute));
}

function $a64489f6d663f3427da3eac0e9$var$isValidWallTime(date, timeZone, absolute) {
  let parts = $a64489f6d663f3427da3eac0e9$var$getTimeZoneParts(absolute, timeZone);
  return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;
}

function toAbsolute(date, timeZone, disambiguation) {
  if (disambiguation === void 0) {
    disambiguation = 'compatible';
  }

  let dateTime = toCalendarDateTime(date); // Fast path: if the time zone is the local timezone and disambiguation is compatible, use native Date.

  if (timeZone === getLocalTimeZone() && disambiguation === 'compatible') {
    dateTime = toCalendar(dateTime, new GregorianCalendar()); // Don't use Date constructor here because two-digit years are interpreted in the 20th century.

    let date = new Date();
    date.setFullYear(dateTime.year, dateTime.month - 1, dateTime.day);
    date.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
    return date.getTime();
  }

  let ms = epochFromDate(dateTime);
  let offsetBefore = getTimeZoneOffset(ms - $a64489f6d663f3427da3eac0e9$var$DAYMILLIS, timeZone);
  let offsetAfter = getTimeZoneOffset(ms + $a64489f6d663f3427da3eac0e9$var$DAYMILLIS, timeZone);
  let valid = $a64489f6d663f3427da3eac0e9$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);

  if (valid.length === 1) {
    return valid[0];
  }

  if (valid.length > 1) {
    switch (disambiguation) {
      // 'compatible' means 'earlier' for "fall back" transitions
      case 'compatible':
      case 'earlier':
        return valid[0];

      case 'later':
        return valid[valid.length - 1];

      case 'reject':
        throw new RangeError('Multiple possible absolute times found');
    }
  }

  switch (disambiguation) {
    case 'earlier':
      return Math.min(ms - offsetBefore, ms - offsetAfter);
    // 'compatible' means 'later' for "spring forward" transitions

    case 'compatible':
    case 'later':
      return Math.max(ms - offsetBefore, ms - offsetAfter);

    case 'reject':
      throw new RangeError('No such absolute time found');
  }
}

exports.toAbsolute = toAbsolute;

function toDate(dateTime, timeZone, disambiguation) {
  if (disambiguation === void 0) {
    disambiguation = 'compatible';
  }

  return new Date(toAbsolute(dateTime, timeZone, disambiguation));
}

exports.toDate = toDate;

function fromAbsolute(ms, timeZone) {
  let offset = getTimeZoneOffset(ms, timeZone);
  let date = new Date(ms + offset);
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth() + 1;
  let day = date.getUTCDate();
  let hour = date.getUTCHours();
  let minute = date.getUTCMinutes();
  let second = date.getUTCSeconds();
  let millisecond = date.getUTCMilliseconds();
  return new ZonedDateTime(year, month, day, timeZone, offset, hour, minute, second, millisecond);
}

exports.fromAbsolute = fromAbsolute;

function fromDate(date, timeZone) {
  return fromAbsolute(date.getTime(), timeZone);
}

exports.fromDate = fromDate;

function fromDateToLocal(date) {
  return fromDate(date, getLocalTimeZone());
}

exports.fromDateToLocal = fromDateToLocal;

function toCalendarDate(dateTime) {
  return new CalendarDate(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}

exports.toCalendarDate = toCalendarDate;

function toDateFields(date) {
  return {
    era: date.era,
    year: date.year,
    month: date.month,
    day: date.day
  };
}

exports.toDateFields = toDateFields;

function toTimeFields(date) {
  return {
    hour: date.hour,
    minute: date.minute,
    second: date.second,
    millisecond: date.millisecond
  };
}

exports.toTimeFields = toTimeFields;

function toCalendarDateTime(date, time) {
  let hour = 0,
      minute = 0,
      second = 0,
      millisecond = 0;

  if ('timeZone' in date) {
    ({
      hour,
      minute,
      second,
      millisecond
    } = date);
  } else if ('hour' in date && !time) {
    return date;
  }

  if (time) {
    ({
      hour,
      minute,
      second,
      millisecond
    } = time);
  }

  return new CalendarDateTime(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}

exports.toCalendarDateTime = toCalendarDateTime;

function toTime(dateTime) {
  return new Time(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
}

exports.toTime = toTime;

function toCalendar(date, calendar) {
  if (date.calendar.identifier === calendar.identifier) {
    return date;
  }

  let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
  let copy = date.copy();
  copy.calendar = calendar;
  copy.era = calendarDate.era;
  copy.year = calendarDate.year;
  copy.month = calendarDate.month;
  copy.day = calendarDate.day;
  return copy;
}

exports.toCalendar = toCalendar;

function toZoned(date, timeZone, disambiguation) {
  if (date instanceof ZonedDateTime) {
    if (date.timeZone === timeZone) {
      return date;
    }

    return toTimeZone(date, timeZone);
  }

  let ms = toAbsolute(date, timeZone, disambiguation);
  return fromAbsolute(ms, timeZone);
}

exports.toZoned = toZoned;

function zonedToDate(date) {
  let ms = epochFromDate(date) - date.offset;
  return new Date(ms);
}

exports.zonedToDate = zonedToDate;

function toTimeZone(date, timeZone) {
  let ms = epochFromDate(date) - date.offset;
  return toCalendar(fromAbsolute(ms, timeZone), date.calendar);
}

exports.toTimeZone = toTimeZone;

function toLocalTimeZone(date) {
  return toTimeZone(date, getLocalTimeZone());
}

exports.toLocalTimeZone = toLocalTimeZone;
const $ef0e396d65262cb58648549e1b295ffb$var$ONE_HOUR = 3600000;

function $ef0e396d65262cb58648549e1b295ffb$export$add(date, duration) {
  let mutableDate = date.copy();
  let days = 'hour' in date ? $ef0e396d65262cb58648549e1b295ffb$var$addTimeFields(date, duration) : 0;
  $ef0e396d65262cb58648549e1b295ffb$var$addYears(mutableDate, duration.years || 0);

  if (mutableDate.calendar.balanceYearMonth) {
    mutableDate.calendar.balanceYearMonth(mutableDate, date);
  }

  mutableDate.month += duration.months || 0;
  $ef0e396d65262cb58648549e1b295ffb$var$balanceYearMonth(mutableDate);
  $ef0e396d65262cb58648549e1b295ffb$var$constrainMonthDay(mutableDate);
  mutableDate.day += (duration.weeks || 0) * 7;
  mutableDate.day += duration.days || 0;
  mutableDate.day += days;
  $ef0e396d65262cb58648549e1b295ffb$var$balanceDay(mutableDate);

  if (mutableDate.calendar.balanceDate) {
    mutableDate.calendar.balanceDate(mutableDate);
  }

  return mutableDate;
}

function $ef0e396d65262cb58648549e1b295ffb$var$addYears(date, years) {
  if (date.calendar.getYearsToAdd) {
    years = date.calendar.getYearsToAdd(date, years);
  }

  date.year += years;
}

function $ef0e396d65262cb58648549e1b295ffb$var$balanceYearMonth(date) {
  while (date.month < 1) {
    $ef0e396d65262cb58648549e1b295ffb$var$addYears(date, -1);
    date.month += date.calendar.getMonthsInYear(date);
  }

  let monthsInYear = 0;

  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
    date.month -= monthsInYear;
    $ef0e396d65262cb58648549e1b295ffb$var$addYears(date, 1);
  }
}

function $ef0e396d65262cb58648549e1b295ffb$var$balanceDay(date) {
  while (date.day < 1) {
    date.month--;
    $ef0e396d65262cb58648549e1b295ffb$var$balanceYearMonth(date);
    date.day += date.calendar.getDaysInMonth(date);
  }

  while (date.day > date.calendar.getDaysInMonth(date)) {
    date.day -= date.calendar.getDaysInMonth(date);
    date.month++;
    $ef0e396d65262cb58648549e1b295ffb$var$balanceYearMonth(date);
  }
}

function $ef0e396d65262cb58648549e1b295ffb$var$constrainMonthDay(date) {
  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}

function $ef0e396d65262cb58648549e1b295ffb$export$constrain(date) {
  if (date.calendar.constrainDate) {
    date.calendar.constrainDate(date);
  }

  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
  $ef0e396d65262cb58648549e1b295ffb$var$constrainMonthDay(date);
}

function $ef0e396d65262cb58648549e1b295ffb$export$invertDuration(duration) {
  let inverseDuration = {};

  for (let key in duration) {
    if (typeof duration[key] === 'number') {
      inverseDuration[key] = -duration[key];
    }
  }

  return inverseDuration;
}

function $ef0e396d65262cb58648549e1b295ffb$export$subtract(date, duration) {
  return $ef0e396d65262cb58648549e1b295ffb$export$add(date, $ef0e396d65262cb58648549e1b295ffb$export$invertDuration(duration));
}

function $ef0e396d65262cb58648549e1b295ffb$export$set(date, fields) {
  let mutableDate = date.copy();

  if (fields.era != null) {
    mutableDate.era = fields.era;
  }

  if (fields.year != null) {
    mutableDate.year = fields.year;
  }

  if (fields.month != null) {
    mutableDate.month = fields.month;
  }

  if (fields.day != null) {
    mutableDate.day = fields.day;
  }

  $ef0e396d65262cb58648549e1b295ffb$export$constrain(mutableDate);
  return mutableDate;
}

function $ef0e396d65262cb58648549e1b295ffb$export$setTime(value, fields) {
  let mutableValue = value.copy();

  if (fields.hour != null) {
    mutableValue.hour = fields.hour;
  }

  if (fields.minute != null) {
    mutableValue.minute = fields.minute;
  }

  if (fields.second != null) {
    mutableValue.second = fields.second;
  }

  if (fields.millisecond != null) {
    mutableValue.millisecond = fields.millisecond;
  }

  $ef0e396d65262cb58648549e1b295ffb$export$constrainTime(mutableValue);
  return mutableValue;
}

function $ef0e396d65262cb58648549e1b295ffb$var$balanceTime(time) {
  time.second += Math.floor(time.millisecond / 1000);
  time.millisecond = $ef0e396d65262cb58648549e1b295ffb$var$nonNegativeMod(time.millisecond, 1000);
  time.minute += Math.floor(time.second / 60);
  time.second = $ef0e396d65262cb58648549e1b295ffb$var$nonNegativeMod(time.second, 60);
  time.hour += Math.floor(time.minute / 60);
  time.minute = $ef0e396d65262cb58648549e1b295ffb$var$nonNegativeMod(time.minute, 60);
  let days = Math.floor(time.hour / 24);
  time.hour = $ef0e396d65262cb58648549e1b295ffb$var$nonNegativeMod(time.hour, 24);
  return days;
}

function $ef0e396d65262cb58648549e1b295ffb$export$constrainTime(time) {
  time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));
  time.second = Math.max(0, Math.min(time.second, 59));
  time.minute = Math.max(0, Math.min(time.minute, 59));
  time.hour = Math.max(0, Math.min(time.hour, 23));
}

function $ef0e396d65262cb58648549e1b295ffb$var$nonNegativeMod(a, b) {
  let result = a % b;

  if (result < 0) {
    result += b;
  }

  return result;
}

function $ef0e396d65262cb58648549e1b295ffb$var$addTimeFields(time, duration) {
  time.hour += duration.hours || 0;
  time.minute += duration.minutes || 0;
  time.second += duration.seconds || 0;
  time.millisecond += duration.milliseconds || 0;
  return $ef0e396d65262cb58648549e1b295ffb$var$balanceTime(time);
}

function $ef0e396d65262cb58648549e1b295ffb$export$addTime(time, duration) {
  let res = time.copy();
  $ef0e396d65262cb58648549e1b295ffb$var$addTimeFields(res, duration);
  return res;
}

function $ef0e396d65262cb58648549e1b295ffb$export$subtractTime(time, duration) {
  return $ef0e396d65262cb58648549e1b295ffb$export$addTime(time, $ef0e396d65262cb58648549e1b295ffb$export$invertDuration(duration));
}

function $ef0e396d65262cb58648549e1b295ffb$export$cycleDate(value, field, amount, options) {
  let mutable = value.copy();

  switch (field) {
    case 'era':
      {
        let eras = value.calendar.getEras();
        let eraIndex = eras.indexOf(value.era);

        if (eraIndex < 0) {
          throw new Error('Invalid era: ' + value.era);
        }

        eraIndex = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options == null ? void 0 : options.round);
        mutable.era = eras[eraIndex]; // Constrain the year and other fields within the era, so the era doesn't change when we balance below.

        $ef0e396d65262cb58648549e1b295ffb$export$constrain(mutable);
        break;
      }

    case 'year':
      {
        if (mutable.calendar.getYearsToAdd) {
          amount = mutable.calendar.getYearsToAdd(mutable, amount);
        } // The year field should not cycle within the era as that can cause weird behavior affecting other fields.
        // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back
        // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.


        mutable.year = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(value.year, amount, -Infinity, 9999, options == null ? void 0 : options.round);

        if (mutable.year === -Infinity) {
          mutable.year = 1;
        }

        if (mutable.calendar.balanceYearMonth) {
          mutable.calendar.balanceYearMonth(mutable, value);
        }

        break;
      }

    case 'month':
      mutable.month = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options == null ? void 0 : options.round);
      break;

    case 'day':
      mutable.day = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options == null ? void 0 : options.round);
      break;

    default:
      throw new Error('Unsupported field ' + field);
  }

  if (value.calendar.balanceDate) {
    value.calendar.balanceDate(mutable);
  }

  $ef0e396d65262cb58648549e1b295ffb$export$constrain(mutable);
  return mutable;
}

function $ef0e396d65262cb58648549e1b295ffb$export$cycleTime(value, field, amount, options) {
  let mutable = value.copy();

  switch (field) {
    case 'hour':
      {
        let hours = value.hour;
        let min = 0;
        let max = 23;

        if ((options == null ? void 0 : options.hourCycle) === 12) {
          let isPM = hours >= 12;
          min = isPM ? 12 : 0;
          max = isPM ? 23 : 11;
        }

        mutable.hour = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(hours, amount, min, max, options == null ? void 0 : options.round);
        break;
      }

    case 'minute':
      mutable.minute = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(value.minute, amount, 0, 59, options == null ? void 0 : options.round);
      break;

    case 'second':
      mutable.second = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(value.second, amount, 0, 59, options == null ? void 0 : options.round);
      break;

    case 'millisecond':
      mutable.millisecond = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(value.millisecond, amount, 0, 999, options == null ? void 0 : options.round);
      break;

    default:
      throw new Error('Unsupported field ' + field);
  }

  return mutable;
}

function $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(value, amount, min, max, round) {
  if (round === void 0) {
    round = false;
  }

  if (round) {
    value += Math.sign(amount);

    if (value < min) {
      value = max;
    }

    let div = Math.abs(amount);

    if (amount > 0) {
      value = Math.ceil(value / div) * div;
    } else {
      value = Math.floor(value / div) * div;
    }

    if (value > max) {
      value = min;
    }
  } else {
    value += amount;

    if (value < min) {
      value = max - (min - value - 1);
    } else if (value > max) {
      value = min + (value - max - 1);
    }
  }

  return value;
}

function $ef0e396d65262cb58648549e1b295ffb$export$addZoned(dateTime, duration) {
  let ms;

  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.days != null && duration.days !== 0) {
    let res = $ef0e396d65262cb58648549e1b295ffb$export$add(toCalendarDateTime(dateTime), {
      years: duration.years,
      months: duration.months,
      days: duration.days
    }); // Changing the date may change the timezone offset, so we need to recompute
    // using the 'compatible' disambiguation.

    ms = toAbsolute(res, dateTime.timeZone);
  } else {
    // Otherwise, preserve the offset of the original date.
    ms = epochFromDate(dateTime) - dateTime.offset;
  } // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.
  // For example, adding one hour during a DST transition may result in the hour field staying the same or
  // skipping an hour. This results in the offset field changing value instead of the specified field.


  ms += duration.milliseconds || 0;
  ms += (duration.seconds || 0) * 1000;
  ms += (duration.minutes || 0) * 60 * 1000;
  ms += (duration.hours || 0) * 60 * 60 * 1000;
  let res = fromAbsolute(ms, dateTime.timeZone);
  return toCalendar(res, dateTime.calendar);
}

function $ef0e396d65262cb58648549e1b295ffb$export$subtractZoned(dateTime, duration) {
  return $ef0e396d65262cb58648549e1b295ffb$export$addZoned(dateTime, $ef0e396d65262cb58648549e1b295ffb$export$invertDuration(duration));
}

function $ef0e396d65262cb58648549e1b295ffb$export$cycleZoned(dateTime, field, amount, options) {
  // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.
  // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC
  // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.
  switch (field) {
    case 'hour':
      {
        let min = 0;
        let max = 23;

        if ((options == null ? void 0 : options.hourCycle) === 12) {
          let isPM = dateTime.hour >= 12;
          min = isPM ? 12 : 0;
          max = isPM ? 23 : 11;
        } // The minimum and maximum hour may be affected by daylight saving time.
        // For example, it might jump forward at midnight, and skip 1am.
        // Or it might end at midnight and repeat the 11pm hour. To handle this, we get
        // the possible absolute times for the min and max, and find the maximum range
        // that is within the current day.


        let plainDateTime = toCalendarDateTime(dateTime);
        let minDate = toCalendar($ef0e396d65262cb58648549e1b295ffb$export$setTime(plainDateTime, {
          hour: min
        }), new GregorianCalendar());
        let minAbsolute = [toAbsolute(minDate, dateTime.timeZone, 'earlier'), toAbsolute(minDate, dateTime.timeZone, 'later')].filter(ms => fromAbsolute(ms, dateTime.timeZone).day === minDate.day)[0];
        let maxDate = toCalendar($ef0e396d65262cb58648549e1b295ffb$export$setTime(plainDateTime, {
          hour: max
        }), new GregorianCalendar());
        let maxAbsolute = [toAbsolute(maxDate, dateTime.timeZone, 'earlier'), toAbsolute(maxDate, dateTime.timeZone, 'later')].filter(ms => fromAbsolute(ms, dateTime.timeZone).day === maxDate.day).pop(); // Since hours may repeat, we need to operate on the absolute time in milliseconds.
        // This is done in hours from the Unix epoch so that cycleValue works correctly,
        // and then converted back to milliseconds.

        let ms = epochFromDate(dateTime) - dateTime.offset;
        let hours = Math.floor(ms / $ef0e396d65262cb58648549e1b295ffb$var$ONE_HOUR);
        let remainder = ms % $ef0e396d65262cb58648549e1b295ffb$var$ONE_HOUR;
        ms = $ef0e396d65262cb58648549e1b295ffb$var$cycleValue(hours, amount, Math.floor(minAbsolute / $ef0e396d65262cb58648549e1b295ffb$var$ONE_HOUR), Math.floor(maxAbsolute / $ef0e396d65262cb58648549e1b295ffb$var$ONE_HOUR), options == null ? void 0 : options.round) * $ef0e396d65262cb58648549e1b295ffb$var$ONE_HOUR + remainder; // Now compute the new timezone offset, and convert the absolute time back to local time.

        return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);
      }

    case 'minute':
    case 'second':
    case 'millisecond':
      // @ts-ignore
      return $ef0e396d65262cb58648549e1b295ffb$export$cycleTime(dateTime, field, amount, options);

    case 'era':
    case 'year':
    case 'month':
    case 'day':
      {
        let res = $ef0e396d65262cb58648549e1b295ffb$export$cycleDate(toCalendarDateTime(dateTime), field, amount, options);
        let ms = toAbsolute(res, dateTime.timeZone);
        return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);
      }

    default:
      throw new Error('Unsupported field ' + field);
  }
}

function $ef0e396d65262cb58648549e1b295ffb$export$setZoned(dateTime, fields, disambiguation) {
  // Set the date/time fields, and recompute the UTC offset to account for DST changes.
  // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.
  let plainDateTime = toCalendarDateTime(dateTime);
  let res = $ef0e396d65262cb58648549e1b295ffb$export$setTime($ef0e396d65262cb58648549e1b295ffb$export$set(plainDateTime, fields), fields); // If the resulting plain date time values are equal, return the original time.
  // We don't want to change the offset when setting the time to the same value.

  if (res.compare(plainDateTime) === 0) {
    return dateTime;
  }

  let ms = toAbsolute(res, dateTime.timeZone, disambiguation);
  return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);
}

const $bd6bf09705eeaa0793e81f11d$var$TIME_RE = /^(\d{2})(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
const $bd6bf09705eeaa0793e81f11d$var$DATE_RE = /^(\d{4})-(\d{2})-(\d{2})$/;
const $bd6bf09705eeaa0793e81f11d$var$DATE_TIME_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
const $bd6bf09705eeaa0793e81f11d$var$ZONED_DATE_TIME_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::(\d{2}))?)?\[(.*?)\]$/;
const $bd6bf09705eeaa0793e81f11d$var$ABSOLUTE_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::(\d{2}))?)|Z)$/;

function parseTime(value) {
  let m = value.match($bd6bf09705eeaa0793e81f11d$var$TIME_RE);

  if (!m) {
    throw new Error('Invalid ISO 8601 time string: ' + value);
  }

  return new Time($bd6bf09705eeaa0793e81f11d$var$parseNumber(m[1], 0, 23), m[2] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[2], 0, 59) : 0, m[3] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[3], 0, 59) : 0, m[4] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[4], 0, Infinity) * 1000 : 0);
}

exports.parseTime = parseTime;

function parseDate(value) {
  let m = value.match($bd6bf09705eeaa0793e81f11d$var$DATE_RE);

  if (!m) {
    throw new Error('Invalid ISO 8601 date string: ' + value);
  }

  let date = new CalendarDate($bd6bf09705eeaa0793e81f11d$var$parseNumber(m[1], 0, 9999), $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[2], 1, 12), 1);
  date.day = $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
  return date;
}

exports.parseDate = parseDate;

function parseDateTime(value) {
  let m = value.match($bd6bf09705eeaa0793e81f11d$var$DATE_TIME_RE);

  if (!m) {
    throw new Error('Invalid ISO 8601 date time string: ' + value);
  }

  let date = new CalendarDateTime($bd6bf09705eeaa0793e81f11d$var$parseNumber(m[1], 1, 9999), $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[2], 1, 12), 1, m[4] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
  date.day = $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
  return date;
}

exports.parseDateTime = parseDateTime;

function parseZonedDateTime(value, disambiguation) {
  let m = value.match($bd6bf09705eeaa0793e81f11d$var$ZONED_DATE_TIME_RE);

  if (!m) {
    throw new Error('Invalid ISO 8601 date time string: ' + value);
  }

  let date = new ZonedDateTime($bd6bf09705eeaa0793e81f11d$var$parseNumber(m[1], 1, 9999), $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[2], 1, 12), 1, m[10], 0, m[4] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
  date.day = $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
  let plainDateTime = toCalendarDateTime(date);
  let ms;

  if (m[8]) {
    var _m$;

    date.offset = $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[8], -23, 23) * 60 * 60 * 1000 + $bd6bf09705eeaa0793e81f11d$var$parseNumber((_m$ = m[9]) != null ? _m$ : '0', 0, 59) * 60 * 1000;
    ms = epochFromDate(date) - date.offset; // Validate offset against parsed date.

    let absolutes = possibleAbsolutes(plainDateTime, date.timeZone);

    if (!absolutes.includes(ms)) {
      throw new Error("Offset " + $bd6bf09705eeaa0793e81f11d$var$offsetToString(date.offset) + " is invalid for " + dateTimeToString(date) + " in " + date.timeZone);
    }
  } else {
    // Convert to absolute and back to fix invalid times due to DST.
    ms = toAbsolute(toCalendarDateTime(plainDateTime), date.timeZone, disambiguation);
  }

  return fromAbsolute(ms, date.timeZone);
}

exports.parseZonedDateTime = parseZonedDateTime;

function parseAbsolute(value, timeZone) {
  let m = value.match($bd6bf09705eeaa0793e81f11d$var$ABSOLUTE_RE);

  if (!m) {
    throw new Error('Invalid ISO 8601 date time string: ' + value);
  }

  let date = new ZonedDateTime($bd6bf09705eeaa0793e81f11d$var$parseNumber(m[1], 1, 9999), $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[2], 1, 12), 1, timeZone, 0, m[4] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
  date.day = $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));

  if (m[8]) {
    var _m$2;

    date.offset = $bd6bf09705eeaa0793e81f11d$var$parseNumber(m[8], -23, 23) * 60 * 60 * 1000 + $bd6bf09705eeaa0793e81f11d$var$parseNumber((_m$2 = m[9]) != null ? _m$2 : '0', 0, 59) * 60 * 1000;
  }

  return toTimeZone(date, timeZone);
}

exports.parseAbsolute = parseAbsolute;

function parseAbsoluteToLocal(value) {
  return parseAbsolute(value, getLocalTimeZone());
}

exports.parseAbsoluteToLocal = parseAbsoluteToLocal;

function $bd6bf09705eeaa0793e81f11d$var$parseNumber(value, min, max) {
  let val = Number(value);

  if (val < min || val > max) {
    throw new RangeError("Value out of range: " + min + " <= " + val + " <= " + max);
  }

  return val;
}

function timeToString(time) {
  return String(time.hour).padStart(2, '0') + ":" + String(time.minute).padStart(2, '0') + ":" + String(time.second).padStart(2, '0') + (time.millisecond ? String(time.millisecond / 1000).slice(1) : '');
}

exports.timeToString = timeToString;

function dateToString(date) {
  let gregorianDate = toCalendar(date, new GregorianCalendar());
  return String(gregorianDate.year).padStart(4, '0') + "-" + String(gregorianDate.month).padStart(2, '0') + "-" + String(gregorianDate.day).padStart(2, '0');
}

exports.dateToString = dateToString;

function dateTimeToString(date) {
  // @ts-ignore
  return dateToString(date) + "T" + timeToString(date);
}

exports.dateTimeToString = dateTimeToString;

function $bd6bf09705eeaa0793e81f11d$var$offsetToString(offset) {
  let sign = Math.sign(offset) < 0 ? '-' : '+';
  offset = Math.abs(offset);
  let offsetHours = Math.floor(offset / (60 * 60 * 1000));
  let offsetMinutes = offset % (60 * 60 * 1000) / (60 * 1000);
  return "" + sign + String(offsetHours).padStart(2, '0') + ":" + String(offsetMinutes).padStart(2, '0');
}

function zonedDateTimeToString(date) {
  return "" + dateTimeToString(date) + $bd6bf09705eeaa0793e81f11d$var$offsetToString(date.offset) + "[" + date.timeZone + "]";
}

exports.zonedDateTimeToString = zonedDateTimeToString;

function $d62182d5b5773c92a3ef2afcb06ab$var$shiftArgs(args) {
  let calendar = typeof args[0] === 'object' ? args.shift() : new GregorianCalendar();
  let era;

  if (typeof args[0] === 'string') {
    era = args.shift();
  } else {
    let eras = calendar.getEras();
    era = eras[eras.length - 1];
  }

  let year = args.shift();
  let month = args.shift();
  let day = args.shift();
  return [calendar, era, year, month, day];
}

var $d62182d5b5773c92a3ef2afcb06ab$var$_type = _babelRuntimeHelpersClassPrivateFieldLooseKey("type");

class CalendarDate {
  // This prevents TypeScript from allowing other types with the same fields to match.
  // i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.
  // If that behavior is desired, use the AnyCalendarDate interface instead.
  constructor() {
    Object.defineProperty(this, $d62182d5b5773c92a3ef2afcb06ab$var$_type, {
      writable: true,
      value: void 0
    });
    this.calendar = void 0;
    this.era = void 0;
    this.year = void 0;
    this.month = void 0;
    this.day = void 0;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    let [calendar, era, year, month, day] = $d62182d5b5773c92a3ef2afcb06ab$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    $ef0e396d65262cb58648549e1b295ffb$export$constrain(this);
  }

  copy() {
    if (this.era) {
      return new CalendarDate(this.calendar, this.era, this.year, this.month, this.day);
    } else {
      return new CalendarDate(this.calendar, this.year, this.month, this.day);
    }
  }

  add(duration) {
    return $ef0e396d65262cb58648549e1b295ffb$export$add(this, duration);
  }

  subtract(duration) {
    return $ef0e396d65262cb58648549e1b295ffb$export$subtract(this, duration);
  }

  set(fields) {
    return $ef0e396d65262cb58648549e1b295ffb$export$set(this, fields);
  }

  cycle(field, amount, options) {
    return $ef0e396d65262cb58648549e1b295ffb$export$cycleDate(this, field, amount, options);
  }

  toDate(timeZone) {
    return toDate(this, timeZone);
  }

  toString() {
    return dateToString(this);
  }

  compare(b) {
    return compareDate(this, b);
  }

}

exports.CalendarDate = CalendarDate;

var $d62182d5b5773c92a3ef2afcb06ab$var$_type2 = _babelRuntimeHelpersClassPrivateFieldLooseKey("type");

class Time {
  // This prevents TypeScript from allowing other types with the same fields to match.
  constructor(hour = 0, minute = 0, second = 0, millisecond = 0) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    Object.defineProperty(this, $d62182d5b5773c92a3ef2afcb06ab$var$_type2, {
      writable: true,
      value: void 0
    });
    $ef0e396d65262cb58648549e1b295ffb$export$constrainTime(this);
  }

  copy() {
    return new Time(this.hour, this.minute, this.second, this.millisecond);
  }

  add(duration) {
    return $ef0e396d65262cb58648549e1b295ffb$export$addTime(this, duration);
  }

  subtract(duration) {
    return $ef0e396d65262cb58648549e1b295ffb$export$subtractTime(this, duration);
  }

  set(fields) {
    return $ef0e396d65262cb58648549e1b295ffb$export$setTime(this, fields);
  }

  cycle(field, amount, options) {
    return $ef0e396d65262cb58648549e1b295ffb$export$cycleTime(this, field, amount, options);
  }

  toString() {
    return timeToString(this);
  }

  compare(b) {
    return compareTime(this, b);
  }

}

exports.Time = Time;

var $d62182d5b5773c92a3ef2afcb06ab$var$_type3 = _babelRuntimeHelpersClassPrivateFieldLooseKey("type");

class CalendarDateTime {
  // This prevents TypeScript from allowing other types with the same fields to match.
  constructor() {
    Object.defineProperty(this, $d62182d5b5773c92a3ef2afcb06ab$var$_type3, {
      writable: true,
      value: void 0
    });
    this.calendar = void 0;
    this.era = void 0;
    this.year = void 0;
    this.month = void 0;
    this.day = void 0;
    this.hour = void 0;
    this.minute = void 0;
    this.second = void 0;
    this.millisecond = void 0;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    let [calendar, era, year, month, day] = $d62182d5b5773c92a3ef2afcb06ab$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    $ef0e396d65262cb58648549e1b295ffb$export$constrain(this);
  }

  copy() {
    if (this.era) {
      return new CalendarDateTime(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    } else {
      return new CalendarDateTime(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    }
  }

  add(duration) {
    return $ef0e396d65262cb58648549e1b295ffb$export$add(this, duration);
  }

  subtract(duration) {
    return $ef0e396d65262cb58648549e1b295ffb$export$subtract(this, duration);
  }

  set(fields) {
    return $ef0e396d65262cb58648549e1b295ffb$export$set($ef0e396d65262cb58648549e1b295ffb$export$setTime(this, fields), fields);
  }

  cycle(field, amount, options) {
    switch (field) {
      case 'era':
      case 'year':
      case 'month':
      case 'day':
        return $ef0e396d65262cb58648549e1b295ffb$export$cycleDate(this, field, amount, options);

      default:
        return $ef0e396d65262cb58648549e1b295ffb$export$cycleTime(this, field, amount, options);
    }
  }

  toDate(timeZone) {
    return toDate(this, timeZone);
  }

  toString() {
    return dateTimeToString(this);
  }

  compare(b) {
    let res = compareDate(this, b);

    if (res === 0) {
      return compareTime(this, toCalendarDateTime(b));
    }

    return res;
  }

}

exports.CalendarDateTime = CalendarDateTime;

var $d62182d5b5773c92a3ef2afcb06ab$var$_type4 = _babelRuntimeHelpersClassPrivateFieldLooseKey("type");

class ZonedDateTime {
  // This prevents TypeScript from allowing other types with the same fields to match.
  constructor() {
    Object.defineProperty(this, $d62182d5b5773c92a3ef2afcb06ab$var$_type4, {
      writable: true,
      value: void 0
    });
    this.calendar = void 0;
    this.era = void 0;
    this.year = void 0;
    this.month = void 0;
    this.day = void 0;
    this.hour = void 0;
    this.minute = void 0;
    this.second = void 0;
    this.millisecond = void 0;
    this.timeZone = void 0;
    this.offset = void 0;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    let [calendar, era, year, month, day] = $d62182d5b5773c92a3ef2afcb06ab$var$shiftArgs(args);
    let timeZone = args.shift();
    let offset = args.shift();
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.timeZone = timeZone;
    this.offset = offset;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    $ef0e396d65262cb58648549e1b295ffb$export$constrain(this);
  }

  copy() {
    if (this.era) {
      return new ZonedDateTime(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    } else {
      return new ZonedDateTime(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    }
  }

  add(duration) {
    return $ef0e396d65262cb58648549e1b295ffb$export$addZoned(this, duration);
  }

  subtract(duration) {
    return $ef0e396d65262cb58648549e1b295ffb$export$subtractZoned(this, duration);
  }

  set(fields, disambiguation) {
    return $ef0e396d65262cb58648549e1b295ffb$export$setZoned(this, fields, disambiguation);
  }

  cycle(field, amount, options) {
    return $ef0e396d65262cb58648549e1b295ffb$export$cycleZoned(this, field, amount, options);
  }

  toDate() {
    return zonedToDate(this);
  }

  toString() {
    return zonedDateTimeToString(this);
  }

  toAbsoluteString() {
    return this.toDate().toISOString();
  }

  compare(b) {
    // TODO: Is this a bad idea??
    return this.toDate().getTime() - toZoned(b, this.timeZone).toDate().getTime();
  }

}

exports.ZonedDateTime = ZonedDateTime;
const $d3cec079d200a848225dc29b5c644d27$var$ERA_START_DATES = [[1868, 9, 8], [1912, 7, 30], [1926, 12, 25], [1989, 1, 8], [2019, 5, 1]];
const $d3cec079d200a848225dc29b5c644d27$var$ERA_END_DATES = [[1912, 7, 29], [1926, 12, 24], [1989, 1, 7], [2019, 4, 30]];
const $d3cec079d200a848225dc29b5c644d27$var$ERA_ADDENDS = [1867, 1911, 1925, 1988, 2018];
const $d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES = ['meiji', 'taisho', 'showa', 'heisei', 'reiwa'];

function $d3cec079d200a848225dc29b5c644d27$var$findEraFromGregorianDate(date) {
  const idx = $d3cec079d200a848225dc29b5c644d27$var$ERA_START_DATES.findIndex((_ref) => {
    let [year, month, day] = _ref;

    if (date.year < year) {
      return true;
    }

    if (date.year === year && date.month < month) {
      return true;
    }

    if (date.year === year && date.month === month && date.day < day) {
      return true;
    }

    return false;
  });

  if (idx === -1) {
    return $d3cec079d200a848225dc29b5c644d27$var$ERA_START_DATES.length - 1;
  }

  if (idx === 0) {
    return 0;
  }

  return idx - 1;
}

function $d3cec079d200a848225dc29b5c644d27$var$toGregorian(date) {
  let eraAddend = $d3cec079d200a848225dc29b5c644d27$var$ERA_ADDENDS[$d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES.indexOf(date.era)];

  if (!eraAddend) {
    throw new Error('Unknown era: ' + date.era);
  }

  return new CalendarDate(date.year + eraAddend, date.month, date.day);
}

class JapaneseCalendar extends GregorianCalendar {
  constructor() {
    super(...arguments);
    this.identifier = 'japanese';
  }

  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    let era = $d3cec079d200a848225dc29b5c644d27$var$findEraFromGregorianDate(date);
    date.era = $d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES[era];
    date.year -= $d3cec079d200a848225dc29b5c644d27$var$ERA_ADDENDS[era];
    return date;
  }

  toJulianDay(date) {
    return super.toJulianDay($d3cec079d200a848225dc29b5c644d27$var$toGregorian(date));
  }

  balanceDate(date) {
    let gregorianDate = $d3cec079d200a848225dc29b5c644d27$var$toGregorian(date);
    let era = $d3cec079d200a848225dc29b5c644d27$var$findEraFromGregorianDate(gregorianDate);

    if ($d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES[era] !== date.era) {
      date.era = $d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES[era];
      date.year = gregorianDate.year - $d3cec079d200a848225dc29b5c644d27$var$ERA_ADDENDS[era];
    }
  }

  constrainDate(date) {
    let idx = $d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES.indexOf(date.era);
    let end = $d3cec079d200a848225dc29b5c644d27$var$ERA_END_DATES[idx];

    if (end != null) {
      let [endYear, endMonth, endDay] = end; // Constrain the year to the maximum possible value in the era.
      // Then constrain the month and day fields within that.

      let maxYear = endYear - $d3cec079d200a848225dc29b5c644d27$var$ERA_ADDENDS[idx];
      date.year = Math.min(maxYear, date.year);

      if (date.year === maxYear) {
        date.month = Math.min(endMonth, date.month);

        if (date.month === endMonth) {
          date.day = Math.min(endDay, date.day);
        }
      }

      if (date.year === 1) {
        let [, startMonth, startDay] = $d3cec079d200a848225dc29b5c644d27$var$ERA_START_DATES[idx];
        date.month = Math.max(startMonth, date.month);

        if (date.month === startMonth) {
          date.day = Math.max(startDay, date.day);
        }
      }
    }
  }

  getEras() {
    return $d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES;
  }

  getYearsInEra(date) {
    // Get the number of years in the era, taking into account the date's month and day fields.
    let era = $d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES.indexOf(date.era);
    let next = $d3cec079d200a848225dc29b5c644d27$var$ERA_START_DATES[era + 1];

    if (next == null) {
      return 9999;
    }

    let cur = $d3cec079d200a848225dc29b5c644d27$var$ERA_START_DATES[era];
    let years = next[0] - cur[0];

    if (date.month < next[1] || date.month === next[1] && date.day < next[2]) {
      years++;
    }

    return years;
  }

  getMinimumMonthInYear(date) {
    let start = $d3cec079d200a848225dc29b5c644d27$var$getMinimums(date);
    return start ? start[1] : 1;
  }

  getMinimumDayInMonth(date) {
    let start = $d3cec079d200a848225dc29b5c644d27$var$getMinimums(date);
    return start && date.month === start[1] ? start[2] : 1;
  }

}

exports.JapaneseCalendar = JapaneseCalendar;

function $d3cec079d200a848225dc29b5c644d27$var$getMinimums(date) {
  if (date.year === 1) {
    let idx = $d3cec079d200a848225dc29b5c644d27$var$ERA_NAMES.indexOf(date.era);
    return $d3cec079d200a848225dc29b5c644d27$var$ERA_START_DATES[idx];
  }
}

const $cdfe44306af6bfd9e58fece371a4981$var$BUDDHIST_ERA_START = -543;

class BuddhistCalendar extends GregorianCalendar {
  constructor() {
    super(...arguments);
    this.identifier = 'buddhist';
  }

  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    date.year -= $cdfe44306af6bfd9e58fece371a4981$var$BUDDHIST_ERA_START;
    return date;
  }

  toJulianDay(date) {
    return super.toJulianDay(new CalendarDate(date.year + $cdfe44306af6bfd9e58fece371a4981$var$BUDDHIST_ERA_START, date.month, date.day));
  }

  getEras() {
    return ['BE'];
  }

}

exports.BuddhistCalendar = BuddhistCalendar;
const $bfc8860ccf9284c7ca2a2d1fdf8e42$var$TAIWAN_ERA_START = 1911;

function $bfc8860ccf9284c7ca2a2d1fdf8e42$var$gregorianYear(date) {
  return date.era === 'minguo' ? date.year + $bfc8860ccf9284c7ca2a2d1fdf8e42$var$TAIWAN_ERA_START : 1 - date.year + $bfc8860ccf9284c7ca2a2d1fdf8e42$var$TAIWAN_ERA_START;
}

function $bfc8860ccf9284c7ca2a2d1fdf8e42$var$gregorianToTaiwan(year, date) {
  let y = year - $bfc8860ccf9284c7ca2a2d1fdf8e42$var$TAIWAN_ERA_START;

  if (y > 0) {
    date.era = 'minguo';
    date.year = y;
  } else {
    date.era = 'before_minguo';
    date.year = 1 - y;
  }
}

class TaiwanCalendar extends GregorianCalendar {
  constructor() {
    super(...arguments);
    this.identifier = 'roc';
  }

  // Republic of China
  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    $bfc8860ccf9284c7ca2a2d1fdf8e42$var$gregorianToTaiwan(date.year, date);
    return date;
  }

  toJulianDay(date) {
    return super.toJulianDay(new CalendarDate($bfc8860ccf9284c7ca2a2d1fdf8e42$var$gregorianYear(date), date.month, date.day));
  }

  getEras() {
    return ['before_minguo', 'minguo'];
  }

  balanceDate(date) {
    $bfc8860ccf9284c7ca2a2d1fdf8e42$var$gregorianToTaiwan($bfc8860ccf9284c7ca2a2d1fdf8e42$var$gregorianYear(date), date);
  }

  getYearsToAdd(date, years) {
    return date.era === 'before_minguo' ? -years : years;
  }

}

exports.TaiwanCalendar = TaiwanCalendar;
const $f9a4dcf1024f37434b4f773b9f10f678$var$PERSIAN_EPOCH = 1948321; // 622/03/19 Julian C.E.

function $f9a4dcf1024f37434b4f773b9f10f678$var$isLeapYear(year) {
  let y0 = year > 0 ? year - 474 : year - 473;
  let y1 = $f839ba72fcd1ea0f3280c95c38c6e83$export$mod(y0, 2820) + 474;
  return $f839ba72fcd1ea0f3280c95c38c6e83$export$mod((y1 + 38) * 31, 128) < 31;
}

function $f9a4dcf1024f37434b4f773b9f10f678$var$persianToJulianDay(year, month, day) {
  let y0 = year > 0 ? year - 474 : year - 473;
  let y1 = $f839ba72fcd1ea0f3280c95c38c6e83$export$mod(y0, 2820) + 474;
  let offset = month <= 7 ? 31 * (month - 1) : 30 * (month - 1) + 6;
  return $f9a4dcf1024f37434b4f773b9f10f678$var$PERSIAN_EPOCH - 1 + 1029983 * Math.floor(y0 / 2820) + 365 * (y1 - 1) + Math.floor((31 * y1 - 5) / 128) + offset + day;
}

class PersianCalendar {
  constructor() {
    this.identifier = 'persian';
  }

  fromJulianDay(jd) {
    let d0 = jd - $f9a4dcf1024f37434b4f773b9f10f678$var$persianToJulianDay(475, 1, 1);
    let n2820 = Math.floor(d0 / 1029983);
    let d1 = $f839ba72fcd1ea0f3280c95c38c6e83$export$mod(d0, 1029983);
    let y2820 = d1 === 1029982 ? 2820 : Math.floor((128 * d1 + 46878) / 46751);
    let year = 474 + 2820 * n2820 + y2820;

    if (year <= 0) {
      year--;
    }

    let yDay = jd - $f9a4dcf1024f37434b4f773b9f10f678$var$persianToJulianDay(year, 1, 1) + 1;
    let month = yDay <= 186 ? Math.ceil(yDay / 31) : Math.ceil((yDay - 6) / 31);
    let day = jd - $f9a4dcf1024f37434b4f773b9f10f678$var$persianToJulianDay(year, month, 1) + 1;
    return new CalendarDate(this, year, month, day);
  }

  toJulianDay(date) {
    return $f9a4dcf1024f37434b4f773b9f10f678$var$persianToJulianDay(date.year, date.month, date.day);
  }

  getMonthsInYear() {
    return 12;
  }

  getDaysInMonth(date) {
    if (date.month <= 6) {
      return 31;
    }

    if (date.month <= 11) {
      return 30;
    }

    return $f9a4dcf1024f37434b4f773b9f10f678$var$isLeapYear(date.year) ? 30 : 29;
  }

  getEras() {
    return ['AP'];
  }

  getYearsInEra() {
    return 9999;
  }

}

exports.PersianCalendar = PersianCalendar;
// Starts in 78 AD,
const $f7146730260e0b69febbbb2e5deb182b$var$INDIAN_ERA_START = 78; // The Indian year starts 80 days later than the Gregorian year.

const $f7146730260e0b69febbbb2e5deb182b$var$INDIAN_YEAR_START = 80;

class IndianCalendar extends GregorianCalendar {
  constructor() {
    super(...arguments);
    this.identifier = 'indian';
  }

  fromJulianDay(jd) {
    // Gregorian date for Julian day
    let date = super.fromJulianDay(jd); // Year in Saka era

    let indianYear = date.year - $f7146730260e0b69febbbb2e5deb182b$var$INDIAN_ERA_START; // Day number in Gregorian year (starting from 0)

    let yDay = jd - $fdb27fe8d5b8ff356e836fe61f3645c$export$gregorianToJulianDay(date.year, 1, 1);
    let leapMonth;

    if (yDay < $f7146730260e0b69febbbb2e5deb182b$var$INDIAN_YEAR_START) {
      //  Day is at the end of the preceding Saka year
      indianYear--; // Days in leapMonth this year, previous Gregorian year

      leapMonth = $fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(date.year - 1) ? 31 : 30;
      yDay += leapMonth + 31 * 5 + 30 * 3 + 10;
    } else {
      // Days in leapMonth this year
      leapMonth = $fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(date.year) ? 31 : 30;
      yDay -= $f7146730260e0b69febbbb2e5deb182b$var$INDIAN_YEAR_START;
    }

    let indianMonth;
    let indianDay;

    if (yDay < leapMonth) {
      indianMonth = 1;
      indianDay = yDay + 1;
    } else {
      let mDay = yDay - leapMonth;

      if (mDay < 31 * 5) {
        indianMonth = Math.floor(mDay / 31) + 2;
        indianDay = mDay % 31 + 1;
      } else {
        mDay -= 31 * 5;
        indianMonth = Math.floor(mDay / 30) + 7;
        indianDay = mDay % 30 + 1;
      }
    }

    return new CalendarDate(this, indianYear, indianMonth, indianDay);
  }

  toJulianDay(date) {
    let year = date.year + $f7146730260e0b69febbbb2e5deb182b$var$INDIAN_ERA_START;
    let leapMonth;
    let jd;

    if ($fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(year)) {
      leapMonth = 31;
      jd = $fdb27fe8d5b8ff356e836fe61f3645c$export$gregorianToJulianDay(year, 3, 21);
    } else {
      leapMonth = 30;
      jd = $fdb27fe8d5b8ff356e836fe61f3645c$export$gregorianToJulianDay(year, 3, 22);
    }

    if (date.month === 1) {
      return jd + date.day - 1;
    }

    jd += leapMonth + Math.min(date.month - 2, 5) * 31;

    if (date.month >= 8) {
      jd += (date.month - 7) * 30;
    }

    jd += date.day - 1;
    return jd;
  }

  getDaysInMonth(date) {
    if (date.month === 1 && $fdb27fe8d5b8ff356e836fe61f3645c$export$isLeapYear(date.year + $f7146730260e0b69febbbb2e5deb182b$var$INDIAN_ERA_START)) {
      return 31;
    }

    if (date.month >= 2 && date.month <= 6) {
      return 31;
    }

    return 30;
  }

  getYearsInEra() {
    return 9999;
  }

  getEras() {
    return ['saka'];
  }

}

exports.IndianCalendar = IndianCalendar;
const $a989b48226b9ac44fe33c05c41f3b63$var$CIVIL_EPOC = 1948440; // CE 622 July 16 Friday (Julian calendar) / CE 622 July 19 (Gregorian calendar)

const $a989b48226b9ac44fe33c05c41f3b63$var$ASTRONOMICAL_EPOC = 1948439; // CE 622 July 15 Thursday (Julian calendar)

const $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START = 1300;
const $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_END = 1600;
const $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_START_DAYS = 460322;

function $a989b48226b9ac44fe33c05c41f3b63$var$islamicToJulianDay(epoch, year, month, day) {
  return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;
}

function $a989b48226b9ac44fe33c05c41f3b63$var$julianDayToIslamic(calendar, epoch, jd) {
  let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);
  let month = Math.min(12, Math.ceil((jd - (29 + $a989b48226b9ac44fe33c05c41f3b63$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);
  let day = jd - $a989b48226b9ac44fe33c05c41f3b63$var$islamicToJulianDay(epoch, year, month, 1) + 1;
  return new CalendarDate(calendar, year, month, day);
}

function $a989b48226b9ac44fe33c05c41f3b63$var$isLeapYear(year) {
  return (14 + 11 * year) % 30 < 11;
}

class IslamicCivilCalendar {
  constructor() {
    this.identifier = 'islamic-civil';
  }

  fromJulianDay(jd) {
    return $a989b48226b9ac44fe33c05c41f3b63$var$julianDayToIslamic(this, $a989b48226b9ac44fe33c05c41f3b63$var$CIVIL_EPOC, jd);
  }

  toJulianDay(date) {
    return $a989b48226b9ac44fe33c05c41f3b63$var$islamicToJulianDay($a989b48226b9ac44fe33c05c41f3b63$var$CIVIL_EPOC, date.year, date.month, date.day);
  }

  getDaysInMonth(date) {
    let length = 29 + date.month % 2;

    if (date.month === 12 && $a989b48226b9ac44fe33c05c41f3b63$var$isLeapYear(date.year)) {
      length++;
    }

    return length;
  }

  getMonthsInYear() {
    return 12;
  }

  getDaysInYear(date) {
    return $a989b48226b9ac44fe33c05c41f3b63$var$isLeapYear(date.year) ? 355 : 354;
  }

  getYearsInEra() {
    return 9999;
  }

  getEras() {
    return ['AH'];
  }

}

exports.IslamicCivilCalendar = IslamicCivilCalendar;

class IslamicTabularCalendar extends IslamicCivilCalendar {
  constructor() {
    super(...arguments);
    this.identifier = 'islamic-tbla';
  }

  fromJulianDay(jd) {
    return $a989b48226b9ac44fe33c05c41f3b63$var$julianDayToIslamic(this, $a989b48226b9ac44fe33c05c41f3b63$var$ASTRONOMICAL_EPOC, jd);
  }

  toJulianDay(date) {
    return $a989b48226b9ac44fe33c05c41f3b63$var$islamicToJulianDay($a989b48226b9ac44fe33c05c41f3b63$var$ASTRONOMICAL_EPOC, date.year, date.month, date.day);
  }

} // Generated by scripts/generate-umalqura.js


exports.IslamicTabularCalendar = IslamicTabularCalendar;
const $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_DATA = 'qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=';
let $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_MONTHLENGTH;
let $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START_TABLE;

function $a989b48226b9ac44fe33c05c41f3b63$var$umalquraYearStart(year) {
  return $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_START_DAYS + $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START_TABLE[year - $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START];
}

function $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthLength(year, month) {
  let idx = year - $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START;
  let mask = 0x01 << 11 - (month - 1);

  if (($a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_MONTHLENGTH[idx] & mask) === 0) {
    return 29;
  } else {
    return 30;
  }
}

function $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthStart(year, month) {
  let day = $a989b48226b9ac44fe33c05c41f3b63$var$umalquraYearStart(year);

  for (let i = 1; i < month; i++) {
    day += $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthLength(year, i);
  }

  return day;
}

function $a989b48226b9ac44fe33c05c41f3b63$var$umalquraYearLength(year) {
  return $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START_TABLE[year + 1 - $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START] - $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START_TABLE[year - $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START];
}

class IslamicUmalquraCalendar extends IslamicCivilCalendar {
  constructor() {
    super();
    this.identifier = 'islamic-umalqura';

    if (!$a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_MONTHLENGTH) {
      $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_DATA), c => c.charCodeAt(0)).buffer);
    }

    if (!$a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START_TABLE) {
      $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_END - $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START + 1);
      let yearStart = 0;

      for (let year = $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START; year <= $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_END; year++) {
        $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START_TABLE[year - $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START] = yearStart;

        for (let i = 1; i <= 12; i++) {
          yearStart += $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthLength(year, i);
        }
      }
    }
  }

  fromJulianDay(jd) {
    let days = jd - $a989b48226b9ac44fe33c05c41f3b63$var$CIVIL_EPOC;
    let startDays = $a989b48226b9ac44fe33c05c41f3b63$var$umalquraYearStart($a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START);
    let endDays = $a989b48226b9ac44fe33c05c41f3b63$var$umalquraYearStart($a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_END);

    if (days < startDays || days > endDays) {
      return super.fromJulianDay(jd);
    } else {
      let y = $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START - 1;
      let m = 1;
      let d = 1;

      while (d > 0) {
        y++;
        d = days - $a989b48226b9ac44fe33c05c41f3b63$var$umalquraYearStart(y) + 1;
        let yearLength = $a989b48226b9ac44fe33c05c41f3b63$var$umalquraYearLength(y);

        if (d === yearLength) {
          m = 12;
          break;
        } else if (d < yearLength) {
          let monthLength = $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthLength(y, m);
          m = 1;

          while (d > monthLength) {
            d -= monthLength;
            m++;
            monthLength = $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthLength(y, m);
          }

          break;
        }
      }

      return new CalendarDate(this, y, m, days - $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthStart(y, m) + 1);
    }
  }

  toJulianDay(date) {
    if (date.year < $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START || date.year > $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_END) {
      return super.toJulianDay(date);
    }

    return $a989b48226b9ac44fe33c05c41f3b63$var$CIVIL_EPOC + $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthStart(date.year, date.month) + (date.day - 1);
  }

  getDaysInMonth(date) {
    if (date.year < $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START || date.year > $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_END) {
      return super.getDaysInMonth(date);
    }

    return $a989b48226b9ac44fe33c05c41f3b63$var$umalquraMonthLength(date.year, date.month);
  }

  getDaysInYear(date) {
    if (date.year < $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_START || date.year > $a989b48226b9ac44fe33c05c41f3b63$var$UMALQURA_YEAR_END) {
      return super.getDaysInYear(date);
    }

    return $a989b48226b9ac44fe33c05c41f3b63$var$umalquraYearLength(date.year);
  }

}

exports.IslamicUmalquraCalendar = IslamicUmalquraCalendar;
const $cc2b03afe24b76b3bf6ec565767e7$var$HEBREW_EPOCH = 347997; // Hebrew date calculations are performed in terms of days, hours, and
// "parts" (or halakim), which are 1/1080 of an hour, or 3 1/3 seconds.

const $cc2b03afe24b76b3bf6ec565767e7$var$HOUR_PARTS = 1080;
const $cc2b03afe24b76b3bf6ec565767e7$var$DAY_PARTS = 24 * $cc2b03afe24b76b3bf6ec565767e7$var$HOUR_PARTS; // An approximate value for the length of a lunar month.
// It is used to calculate the approximate year and month of a given
// absolute date.

const $cc2b03afe24b76b3bf6ec565767e7$var$MONTH_DAYS = 29;
const $cc2b03afe24b76b3bf6ec565767e7$var$MONTH_FRACT = 12 * $cc2b03afe24b76b3bf6ec565767e7$var$HOUR_PARTS + 793;
const $cc2b03afe24b76b3bf6ec565767e7$var$MONTH_PARTS = $cc2b03afe24b76b3bf6ec565767e7$var$MONTH_DAYS * $cc2b03afe24b76b3bf6ec565767e7$var$DAY_PARTS + $cc2b03afe24b76b3bf6ec565767e7$var$MONTH_FRACT;

function $cc2b03afe24b76b3bf6ec565767e7$var$isLeapYear(year) {
  return $f839ba72fcd1ea0f3280c95c38c6e83$export$mod(year * 7 + 1, 19) < 7;
} // Test for delay of start of new year and to avoid
// Sunday, Wednesday, and Friday as start of the new year.


function $cc2b03afe24b76b3bf6ec565767e7$var$hebrewDelay1(year) {
  let months = Math.floor((235 * year - 234) / 19);
  let parts = 12084 + 13753 * months;
  let day = months * 29 + Math.floor(parts / 25920);

  if ($f839ba72fcd1ea0f3280c95c38c6e83$export$mod(3 * (day + 1), 7) < 3) {
    day += 1;
  }

  return day;
} // Check for delay in start of new year due to length of adjacent years


function $cc2b03afe24b76b3bf6ec565767e7$var$hebrewDelay2(year) {
  let last = $cc2b03afe24b76b3bf6ec565767e7$var$hebrewDelay1(year - 1);
  let present = $cc2b03afe24b76b3bf6ec565767e7$var$hebrewDelay1(year);
  let next = $cc2b03afe24b76b3bf6ec565767e7$var$hebrewDelay1(year + 1);

  if (next - present === 356) {
    return 2;
  }

  if (present - last === 382) {
    return 1;
  }

  return 0;
}

function $cc2b03afe24b76b3bf6ec565767e7$var$startOfYear(year) {
  return $cc2b03afe24b76b3bf6ec565767e7$var$hebrewDelay1(year) + $cc2b03afe24b76b3bf6ec565767e7$var$hebrewDelay2(year);
}

function $cc2b03afe24b76b3bf6ec565767e7$var$getDaysInYear(year) {
  return $cc2b03afe24b76b3bf6ec565767e7$var$startOfYear(year + 1) - $cc2b03afe24b76b3bf6ec565767e7$var$startOfYear(year);
}

function $cc2b03afe24b76b3bf6ec565767e7$var$getYearType(year) {
  let yearLength = $cc2b03afe24b76b3bf6ec565767e7$var$getDaysInYear(year);

  if (yearLength > 380) {
    yearLength -= 30; // Subtract length of leap month.
  }

  switch (yearLength) {
    case 353:
      return 0;
    // deficient

    case 354:
      return 1;
    // normal

    case 355:
      return 2;
    // complete
  }
}

function $cc2b03afe24b76b3bf6ec565767e7$var$getDaysInMonth(year, month) {
  // Normalize month numbers from 1 - 13, even on non-leap years
  if (month >= 6 && !$cc2b03afe24b76b3bf6ec565767e7$var$isLeapYear(year)) {
    month++;
  } // First of all, dispose of fixed-length 29 day months


  if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) {
    return 29;
  }

  let yearType = $cc2b03afe24b76b3bf6ec565767e7$var$getYearType(year); // If it's Heshvan, days depend on length of year

  if (month === 2) {
    return yearType === 2 ? 30 : 29;
  } // Similarly, Kislev varies with the length of year


  if (month === 3) {
    return yearType === 0 ? 29 : 30;
  } // Adar I only exists in leap years


  if (month === 6) {
    return $cc2b03afe24b76b3bf6ec565767e7$var$isLeapYear(year) ? 30 : 0;
  }

  return 30;
}

class HebrewCalendar {
  constructor() {
    this.identifier = 'hebrew';
  }

  fromJulianDay(jd) {
    let d = jd - $cc2b03afe24b76b3bf6ec565767e7$var$HEBREW_EPOCH;
    let m = d * $cc2b03afe24b76b3bf6ec565767e7$var$DAY_PARTS / $cc2b03afe24b76b3bf6ec565767e7$var$MONTH_PARTS; // Months (approx)

    let year = Math.floor((19 * m + 234) / 235) + 1; // Years (approx)

    let ys = $cc2b03afe24b76b3bf6ec565767e7$var$startOfYear(year); // 1st day of year

    let dayOfYear = Math.floor(d - ys); // Because of the postponement rules, it's possible to guess wrong.  Fix it.

    while (dayOfYear < 1) {
      year--;
      ys = $cc2b03afe24b76b3bf6ec565767e7$var$startOfYear(year);
      dayOfYear = Math.floor(d - ys);
    } // Now figure out which month we're in, and the date within that month


    let month = 1;
    let monthStart = 0;

    while (monthStart < dayOfYear) {
      monthStart += $cc2b03afe24b76b3bf6ec565767e7$var$getDaysInMonth(year, month);
      month++;
    }

    month--;
    monthStart -= $cc2b03afe24b76b3bf6ec565767e7$var$getDaysInMonth(year, month);
    let day = dayOfYear - monthStart;
    return new CalendarDate(this, year, month, day);
  }

  toJulianDay(date) {
    let jd = $cc2b03afe24b76b3bf6ec565767e7$var$startOfYear(date.year);

    for (let month = 1; month < date.month; month++) {
      jd += $cc2b03afe24b76b3bf6ec565767e7$var$getDaysInMonth(date.year, month);
    }

    return jd + date.day + $cc2b03afe24b76b3bf6ec565767e7$var$HEBREW_EPOCH;
  }

  getDaysInMonth(date) {
    return $cc2b03afe24b76b3bf6ec565767e7$var$getDaysInMonth(date.year, date.month);
  }

  getMonthsInYear(date) {
    return $cc2b03afe24b76b3bf6ec565767e7$var$isLeapYear(date.year) ? 13 : 12;
  }

  getDaysInYear(date) {
    return $cc2b03afe24b76b3bf6ec565767e7$var$getDaysInYear(date.year);
  }

  getYearsInEra() {
    return 9999;
  }

  getEras() {
    return ['AM'];
  }

  balanceYearMonth(date, previousDate) {
    // Keep date in the same month when switching between leap years and non leap years
    if (previousDate.year !== date.year) {
      if ($cc2b03afe24b76b3bf6ec565767e7$var$isLeapYear(previousDate.year) && !$cc2b03afe24b76b3bf6ec565767e7$var$isLeapYear(date.year) && previousDate.month > 6) {
        date.month--;
      } else if (!$cc2b03afe24b76b3bf6ec565767e7$var$isLeapYear(previousDate.year) && $cc2b03afe24b76b3bf6ec565767e7$var$isLeapYear(date.year) && previousDate.month > 6) {
        date.month++;
      }
    }
  }

}

exports.HebrewCalendar = HebrewCalendar;
const $e97ab861d6249e3f231cf864175fa721$var$ETHIOPIC_EPOCH = 1723856;
const $e97ab861d6249e3f231cf864175fa721$var$COPTIC_EPOCH = 1824665; // The delta between Amete Alem 1 and Amete Mihret 1
// AA 5501 = AM 1

const $e97ab861d6249e3f231cf864175fa721$var$AMETE_MIHRET_DELTA = 5500;

function $e97ab861d6249e3f231cf864175fa721$var$ceToJulianDay(epoch, year, month, day) {
  return epoch + 365 * year + Math.floor(year / 4) // extra day of leap year
  + 30 * (month - 1) // number of days from months (1 based)
  + day - 1 // number of days for present month (1 based)
  ;
}

function $e97ab861d6249e3f231cf864175fa721$var$julianDayToCE(calendar, epoch, jd) {
  let year = Math.floor(4 * (jd - epoch) / 1461);
  let month = 1 + Math.floor((jd - $e97ab861d6249e3f231cf864175fa721$var$ceToJulianDay(epoch, year, 1, 1)) / 30);
  let day = jd + 1 - $e97ab861d6249e3f231cf864175fa721$var$ceToJulianDay(epoch, year, month, 1);
  return new CalendarDate(calendar, year, month, day);
}

function $e97ab861d6249e3f231cf864175fa721$var$getLeapDay(year) {
  return Math.floor(year % 4 / 3);
}

function $e97ab861d6249e3f231cf864175fa721$var$getDaysInMonth(year, month) {
  // The Ethiopian and Coptic calendars have 13 months, 12 of 30 days each and
  // an intercalary month at the end of the year of 5 or 6 days, depending whether
  // the year is a leap year or not. The Leap Year follows the same rules as the
  // Julian Calendar so that the extra month always has six days in the year before
  // a Julian Leap Year.
  if (month % 13 !== 0) {
    // not intercalary month
    return 30;
  } else {
    // intercalary month 5 days + possible leap day
    return $e97ab861d6249e3f231cf864175fa721$var$getLeapDay(year) + 5;
  }
}

class EthiopicCalendar {
  constructor() {
    this.identifier = 'ethiopic';
  }

  fromJulianDay(jd) {
    let date = $e97ab861d6249e3f231cf864175fa721$var$julianDayToCE(this, $e97ab861d6249e3f231cf864175fa721$var$ETHIOPIC_EPOCH, jd);

    if (date.year > 0) {
      date.era = 'AM';
    } else {
      date.era = 'AA';
      date.year += $e97ab861d6249e3f231cf864175fa721$var$AMETE_MIHRET_DELTA;
    }

    return date;
  }

  toJulianDay(date) {
    let year = date.year;

    if (date.era === 'AA') {
      year -= $e97ab861d6249e3f231cf864175fa721$var$AMETE_MIHRET_DELTA;
    }

    return $e97ab861d6249e3f231cf864175fa721$var$ceToJulianDay($e97ab861d6249e3f231cf864175fa721$var$ETHIOPIC_EPOCH, year, date.month, date.day);
  }

  getDaysInMonth(date) {
    let year = date.year;

    if (date.era === 'AA') {
      year -= $e97ab861d6249e3f231cf864175fa721$var$AMETE_MIHRET_DELTA;
    }

    return $e97ab861d6249e3f231cf864175fa721$var$getDaysInMonth(year, date.month);
  }

  getMonthsInYear() {
    return 13;
  }

  getDaysInYear(date) {
    return 365 + $e97ab861d6249e3f231cf864175fa721$var$getLeapDay(date.year);
  }

  getYearsInEra() {
    return 9999;
  }

  getEras() {
    return ['AA', 'AM'];
  }

}

exports.EthiopicCalendar = EthiopicCalendar;

class EthiopicAmeteAlemCalendar extends EthiopicCalendar {
  constructor() {
    super(...arguments);
    this.identifier = 'ethioaa';
  }

  // also known as 'ethiopic-amete-alem' in ICU
  fromJulianDay(jd) {
    let date = $e97ab861d6249e3f231cf864175fa721$var$julianDayToCE(this, $e97ab861d6249e3f231cf864175fa721$var$ETHIOPIC_EPOCH, jd);
    date.era = 'AA';
    date.year += $e97ab861d6249e3f231cf864175fa721$var$AMETE_MIHRET_DELTA;
    return date;
  }

  getEras() {
    return ['AA'];
  }

}

exports.EthiopicAmeteAlemCalendar = EthiopicAmeteAlemCalendar;

class CopticCalendar extends EthiopicCalendar {
  constructor() {
    super(...arguments);
    this.identifier = 'coptic';
  }

  fromJulianDay(jd) {
    let date = $e97ab861d6249e3f231cf864175fa721$var$julianDayToCE(this, $e97ab861d6249e3f231cf864175fa721$var$COPTIC_EPOCH, jd);

    if (date.year <= 0) {
      date.era = 'BCE';
      date.year = 1 - date.year;
    } else {
      date.era = 'CE';
    }

    return date;
  }

  toJulianDay(date) {
    let year = date.year;

    if (date.era === 'BCE') {
      year = 1 - year;
    }

    return $e97ab861d6249e3f231cf864175fa721$var$ceToJulianDay($e97ab861d6249e3f231cf864175fa721$var$COPTIC_EPOCH, year, date.month, date.day);
  }

  getDaysInMonth(date) {
    let year = date.year;

    if (date.era === 'BCE') {
      year = 1 - year;
    }

    return $e97ab861d6249e3f231cf864175fa721$var$getDaysInMonth(year, date.month);
  }

  getYearsToAdd(date, years) {
    return date.era === 'BCE' ? -years : years;
  }

  getEras() {
    return ['BCE', 'CE'];
  }

}

exports.CopticCalendar = CopticCalendar;

function createCalendar(name) {
  switch (name) {
    case 'buddhist':
      return new BuddhistCalendar();

    case 'ethiopic':
      return new EthiopicCalendar();

    case 'ethioaa':
      return new EthiopicAmeteAlemCalendar();

    case 'coptic':
      return new CopticCalendar();

    case 'hebrew':
      return new HebrewCalendar();

    case 'indian':
      return new IndianCalendar();

    case 'islamic-civil':
      return new IslamicCivilCalendar();

    case 'islamic-tbla':
      return new IslamicTabularCalendar();

    case 'islamic-umalqura':
      return new IslamicUmalquraCalendar();

    case 'japanese':
      return new JapaneseCalendar();

    case 'persian':
      return new PersianCalendar();

    case 'roc':
      return new TaiwanCalendar();

    case 'gregory':
    default:
      return new GregorianCalendar();
  }
}

exports.createCalendar = createCalendar;
let $ecb868e9bf656e44b130863ca06$var$formatterCache = new Map();

class DateFormatter {
  constructor(locale, options) {
    if (options === void 0) {
      options = {};
    }

    this.formatter = void 0;
    this.options = void 0;
    this.resolvedHourCycle = void 0;
    this.formatter = $ecb868e9bf656e44b130863ca06$var$getCachedDateFormatter(locale, options);
    this.options = options;
  }

  format(value) {
    return this.formatter.format(value);
  }

  formatToParts(value) {
    return this.formatter.formatToParts(value);
  }

  formatRange(start, end) {
    // @ts-ignore
    if (typeof this.formatter.formatRange === 'function') {
      // @ts-ignore
      return this.formatter.formatRange(start, end);
    }

    if (end < start) {
      throw new RangeError('End date must be >= start date');
    } // Very basic fallback for old browsers.


    return this.formatter.format(start) + " \u2013 " + this.formatter.format(end);
  }

  formatRangeToParts(start, end) {
    // @ts-ignore
    if (typeof this.formatter.formatRangeToParts === 'function') {
      // @ts-ignore
      return this.formatter.formatRangeToParts(start, end);
    }

    if (end < start) {
      throw new RangeError('End date must be >= start date');
    }

    let startParts = this.formatter.formatToParts(start);
    let endParts = this.formatter.formatToParts(end);
    return [...startParts.map(p => _babelRuntimeHelpersExtends({}, p, {
      source: 'startRange'
    })), {
      type: 'literal',
      value: '  ',
      source: 'shared'
    }, ...endParts.map(p => _babelRuntimeHelpersExtends({}, p, {
      source: 'endRange'
    }))];
  }

  resolvedOptions() {
    let resolvedOptions = this.formatter.resolvedOptions();

    if ($ecb868e9bf656e44b130863ca06$var$hasBuggyResolvedHourCycle()) {
      if (!this.resolvedHourCycle) {
        this.resolvedHourCycle = $ecb868e9bf656e44b130863ca06$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
      }

      resolvedOptions.hourCycle = this.resolvedHourCycle;
      resolvedOptions.hour12 = this.resolvedHourCycle === 'h11' || this.resolvedHourCycle === 'h12';
    }

    return resolvedOptions;
  }

} // There are multiple bugs involving the hour12 and hourCycle options in various browser engines.
//   - Chrome [1] (and the ECMA 402 spec [2]) resolve hour12: false in English and other locales to h24 (24:00 - 23:59)
//     rather than h23 (00:00 - 23:59). Same can happen with hour12: true in French, which Chrome resolves to h11 (00:00 - 11:59)
//     rather than h12 (12:00 - 11:59).
//   - WebKit returns an incorrect hourCycle resolved option in the French locale due to incorrect parsing of 'h' literal
//     in the resolved pattern. It also formats incorrectly when specifying the hourCycle option for the same reason. [3]
// [1] https://bugs.chromium.org/p/chromium/issues/detail?id=1045791
// [2] https://github.com/tc39/ecma402/issues/402
// [3] https://bugs.webkit.org/show_bug.cgi?id=229313
// https://github.com/unicode-org/cldr/blob/018b55eff7ceb389c7e3fc44e2f657eae3b10b38/common/supplemental/supplementalData.xml#L4774-L4802


exports.DateFormatter = DateFormatter;
const $ecb868e9bf656e44b130863ca06$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: 'h11'
  },
  false: {// All locales use h23 for 24 hour time. None use h24.
  }
};

function $ecb868e9bf656e44b130863ca06$var$getCachedDateFormatter(locale, options) {
  if (options === void 0) {
    options = {};
  }

  // Work around buggy hour12 behavior in Chrome / ECMA 402 spec by using hourCycle instead.
  // Only apply the workaround if the issue is detected, because the hourCycle option is buggy in Safari.
  if (typeof options.hour12 === 'boolean' && $ecb868e9bf656e44b130863ca06$var$hasBuggyHour12Behavior()) {
    options = _babelRuntimeHelpersExtends({}, options);
    let pref = $ecb868e9bf656e44b130863ca06$var$hour12Preferences[String(options.hour12)][locale.split('-')[0]];
    let defaultHourCycle = options.hour12 ? 'h12' : 'h23';
    options.hourCycle = pref != null ? pref : defaultHourCycle;
    delete options.hour12;
  }

  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');

  if ($ecb868e9bf656e44b130863ca06$var$formatterCache.has(cacheKey)) {
    return $ecb868e9bf656e44b130863ca06$var$formatterCache.get(cacheKey);
  }

  let numberFormatter = new Intl.DateTimeFormat(locale, options);
  $ecb868e9bf656e44b130863ca06$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}

let $ecb868e9bf656e44b130863ca06$var$_hasBuggyHour12Behavior = null;

function $ecb868e9bf656e44b130863ca06$var$hasBuggyHour12Behavior() {
  if ($ecb868e9bf656e44b130863ca06$var$_hasBuggyHour12Behavior == null) {
    $ecb868e9bf656e44b130863ca06$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat('en-US', {
      hour: 'numeric',
      hour12: false
    }).format(new Date(2020, 2, 3, 0)) === '24';
  }

  return $ecb868e9bf656e44b130863ca06$var$_hasBuggyHour12Behavior;
}

let $ecb868e9bf656e44b130863ca06$var$_hasBuggyResolvedHourCycle = null;

function $ecb868e9bf656e44b130863ca06$var$hasBuggyResolvedHourCycle() {
  if ($ecb868e9bf656e44b130863ca06$var$_hasBuggyResolvedHourCycle == null) {
    $ecb868e9bf656e44b130863ca06$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat('fr', {
      hour: 'numeric',
      hour12: false
    }).resolvedOptions().hourCycle === 'h12';
  }

  return $ecb868e9bf656e44b130863ca06$var$_hasBuggyResolvedHourCycle;
}

function $ecb868e9bf656e44b130863ca06$var$getResolvedHourCycle(locale, options) {
  if (!options.timeStyle && !options.hour) {
    return undefined;
  } // Work around buggy results in resolved hourCycle and hour12 options in WebKit.
  // Format the minimum possible hour and maximum possible hour in a day and parse the results.


  locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, '');
  locale += (locale.includes('-u-') ? '' : '-u') + '-nu-latn';
  let formatter = $ecb868e9bf656e44b130863ca06$var$getCachedDateFormatter(locale, _babelRuntimeHelpersExtends({}, options, {
    timeZone: undefined // use local timezone

  }));
  let min = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find(p => p.type === 'hour').value, 10);
  let max = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find(p => p.type === 'hour').value, 10);

  if (min === 0 && max === 23) {
    return 'h23';
  }

  if (min === 24 && max === 23) {
    return 'h24';
  }

  if (min === 0 && max === 11) {
    return 'h11';
  }

  if (min === 12 && max === 11) {
    return 'h12';
  }

  throw new Error('Unexpected hour cycle result');
}
//# sourceMappingURL=main.js.map
